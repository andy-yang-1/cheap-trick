# from tvm.script import tir as T
@tvm.script.ir_module
class Module:
    @T.prim_func
    def mm(A: T.Buffer[(1024, 1024), "float32"], B: T.Buffer[(1024, 1024), "float32"], Y: T.Buffer[(1024, 1024), "float32"]) -> None:
        # function attr dict
        T.func_attr({"tir.noalias": True, "global_symbol": "mm"})
        # body
        # with T.block("root")
        Y_local = T.alloc_buffer([1024, 1024], dtype="float32", scope="local")
        A_local = T.alloc_buffer([1024, 1024], dtype="float32", scope="local")
        B_local = T.alloc_buffer([1024, 1024], dtype="float32", scope="local")
        A_local_shared = T.alloc_buffer([1024, 1024], dtype="float32", scope="shared")
        B_local_shared = T.alloc_buffer([1024, 1024], dtype="float32", scope="shared")
        A_local_shared_local = T.alloc_buffer([1024, 1024], dtype="float32", scope="local")
        B_local_shared_local = T.alloc_buffer([1024, 1024], dtype="float32", scope="local")
        for i1_0 in T.thread_binding(4, thread="blockIdx.y"):
            for i0_0 in T.thread_binding(64, thread="blockIdx.x"):
                for i1_1 in T.thread_binding(4, thread="vthread.y"):
                    for i0_1 in T.thread_binding(1, thread="vthread.x"):
                        for i1_2 in T.thread_binding(64, thread="threadIdx.y"):
                            for i0_2 in T.thread_binding(1, thread="threadIdx.x"):
                                for i0_3_init, i1_3_init, i0_4_init, i1_4_init in T.grid(16, 1, 1, 1):
                                    with T.block("Y_init"):
                                        i = T.axis.spatial(1024, i0_4_init + i0_0 * 16 + i0_1 * 16 + i0_2 * 16 + i0_3_init)
                                        j = T.axis.spatial(1024, i1_4_init + i1_0 * 256 + i1_1 * 64 + i1_2 + i1_3_init)
                                        T.reads()
                                        T.writes(Y_local[i, j])
                                        Y_local[i, j] = T.float32(0)
                                for i2_0 in T.serial(128, annotations={"software_pipeline_order":[0, 3, 1, 4, 2], "software_pipeline_stage":[0, 0, 0, 0, 1]}):
                                    for ax0_ax1_fused_0 in T.serial(1):
                                        for ax0_ax1_fused_1 in T.thread_binding(64, thread="threadIdx.y"):
                                            for ax0_ax1_fused_2 in T.thread_binding(1, thread="threadIdx.x"):
                                                for ax0_ax1_fused_3 in T.vectorized(4):
                                                    with T.block("A_local"):
                                                        T.where((ax0_ax1_fused_0 * 64 + ax0_ax1_fused_1 + ax0_ax1_fused_2) * 4 + ax0_ax1_fused_3 < 128)
                                                        v0 = T.axis.spatial(1024, i0_0 * 16 + (ax0_ax1_fused_0 * 256 + ax0_ax1_fused_1 * 4 + ax0_ax1_fused_2 * 4 + ax0_ax1_fused_3) // 8)
                                                        v1 = T.axis.spatial(1024, i2_0 * 8 + (ax0_ax1_fused_0 * 256 + ax0_ax1_fused_1 * 4 + ax0_ax1_fused_2 * 4 + ax0_ax1_fused_3) % 8)
                                                        T.reads(A[v0, v1])
                                                        T.writes(A_local[v0, v1])
                                                        A_local[v0, v1] = A[v0, v1]
                                    for ax0_ax1_fused_0 in T.serial(1):
                                        for ax0_ax1_fused_1 in T.thread_binding(64, thread="threadIdx.y"):
                                            for ax0_ax1_fused_2 in T.thread_binding(1, thread="threadIdx.x"):
                                                for ax0_ax1_fused_3 in T.vectorized(2):
                                                    with T.block("A_local_shared"):
                                                        v0 = T.axis.spatial(1024, i0_0 * 16 + (ax0_ax1_fused_0 * 128 + ax0_ax1_fused_1 * 2 + ax0_ax1_fused_2 * 2 + ax0_ax1_fused_3) // 8)
                                                        v1 = T.axis.spatial(1024, i2_0 * 8 + (ax0_ax1_fused_0 * 128 + ax0_ax1_fused_1 * 2 + ax0_ax1_fused_2 * 2 + ax0_ax1_fused_3) % 8)
                                                        T.reads(A_local[v0, v1])
                                                        T.writes(A_local_shared[v1, v0 // 128 * 128 + v0 % 8 // 4 * 64 + v0 % 128 // 8 * 4 + v0 % 4])
                                                        T.block_attr({"double_buffer_scope":0})
                                                        A_local_shared[v1, v0 // 128 * 128 + v0 % 8 // 4 * 64 + v0 % 128 // 8 * 4 + v0 % 4] = A_local[v0, v1]
                                    for ax0_ax1_fused_0 in T.serial(16):
                                        for ax0_ax1_fused_1 in T.thread_binding(64, thread="threadIdx.y"):
                                            for ax0_ax1_fused_2 in T.thread_binding(1, thread="threadIdx.x"):
                                                for ax0_ax1_fused_3 in T.vectorized(2):
                                                    with T.block("B_local"):
                                                        v0 = T.axis.spatial(1024, i2_0 * 8 + (ax0_ax1_fused_0 * 128 + ax0_ax1_fused_1 * 2 + ax0_ax1_fused_2 * 2 + ax0_ax1_fused_3) // 256)
                                                        v1 = T.axis.spatial(1024, i1_0 * 256 + (ax0_ax1_fused_0 * 128 + ax0_ax1_fused_1 * 2 + ax0_ax1_fused_2 * 2 + ax0_ax1_fused_3) % 256)
                                                        T.reads(B[v0, v1])
                                                        T.writes(B_local[v0, v1])
                                                        B_local[v0, v1] = B[v0, v1]
                                    for ax0_ax1_fused_0 in T.serial(16):
                                        for ax0_ax1_fused_1 in T.thread_binding(64, thread="threadIdx.y"):
                                            for ax0_ax1_fused_2 in T.thread_binding(1, thread="threadIdx.x"):
                                                for ax0_ax1_fused_3 in T.vectorized(2):
                                                    with T.block("B_local_shared"):
                                                        v0 = T.axis.spatial(1024, i2_0 * 8 + (ax0_ax1_fused_0 * 128 + ax0_ax1_fused_1 * 2 + ax0_ax1_fused_2 * 2 + ax0_ax1_fused_3) // 256)
                                                        v1 = T.axis.spatial(1024, i1_0 * 256 + (ax0_ax1_fused_0 * 128 + ax0_ax1_fused_1 * 2 + ax0_ax1_fused_2 * 2 + ax0_ax1_fused_3) % 256)
                                                        T.reads(B_local[v0, v1])
                                                        T.writes(B_local_shared[v0, v1 // 128 * 128 + v1 % 8 // 4 * 64 + v1 % 128 // 8 * 4 + v1 % 4])
                                                        T.block_attr({"double_buffer_scope":0})
                                                        B_local_shared[v0, v1 // 128 * 128 + v1 % 8 // 4 * 64 + v1 % 128 // 8 * 4 + v1 % 4] = B_local[v0, v1]
                                    for i2_1 in T.unroll(4):
                                        for i0_3, i1_3 in T.grid(16, 1):
                                            for i2_2 in T.unroll(2):
                                                for ax0_ax1_fused_0 in T.unroll(1):
                                                    for ax0_ax1_fused_1 in T.vectorized(3):
                                                        with T.block("A_local_shared_local"):
                                                            T.where(ax0_ax1_fused_0 * 3 + ax0_ax1_fused_1 < 1)
                                                            v0 = T.axis.spatial(1024, i0_0 * 16 + i0_3)
                                                            v1 = T.axis.spatial(1024, i2_0 * 8 + i2_1 * 2 + i2_2)
                                                            T.reads(A_local_shared[v1, v0 // 128 * 128 + v0 % 8 // 4 * 64 + v0 % 128 // 8 * 4 + v0 % 4])
                                                            T.writes(A_local_shared_local[v0, v1])
                                                            A_local_shared_local[v0, v1] = A_local_shared[v1, v0 // 128 * 128 + v0 % 8 // 4 * 64 + v0 % 128 // 8 * 4 + v0 % 4]
                                                for ax0_ax1_fused_0 in T.unroll(1):
                                                    for ax0_ax1_fused_1 in T.vectorized(4):
                                                        with T.block("B_local_shared_local"):
                                                            T.where(ax0_ax1_fused_0 * 4 + ax0_ax1_fused_1 < 1)
                                                            v0 = T.axis.spatial(1024, i2_0 * 8 + i2_1 * 2 + i2_2)
                                                            v1 = T.axis.spatial(1024, i1_0 * 256 + i1_1 * 64 + i1_2)
                                                            T.reads(B_local_shared[v0, v1 // 128 * 128 + v1 % 8 // 4 * 64 + v1 % 128 // 8 * 4 + v1 % 4])
                                                            T.writes(B_local_shared_local[v0, v1])
                                                            B_local_shared_local[v0, v1] = B_local_shared[v0, v1 // 128 * 128 + v1 % 8 // 4 * 64 + v1 % 128 // 8 * 4 + v1 % 4]
                                                for i0_4, i1_4 in T.grid(1, 1):
                                                    with T.block("Y_update"):
                                                        i = T.axis.spatial(1024, i0_4 + i0_0 * 16 + i0_1 * 16 + i0_2 * 16 + i0_3)
                                                        j = T.axis.spatial(1024, i1_4 + i1_0 * 256 + i1_1 * 64 + i1_2 + i1_3)
                                                        k = T.axis.reduce(1024, i2_0 * 8 + i2_1 * 2 + i2_2)
                                                        T.reads(Y_local[i, j], A_local_shared_local[i, k], B_local_shared_local[k, j])
                                                        T.writes(Y_local[i, j])
                                                        Y_local[i, j] = Y_local[i, j] + A_local_shared_local[i, k] * B_local_shared_local[k, j]
                                for ax0, ax1 in T.grid(16, 1):
                                    with T.block("Y_local"):
                                        v0 = T.axis.spatial(1024, i0_0 * 16 + ax0)
                                        v1 = T.axis.spatial(1024, i1_0 * 256 + i1_1 * 64 + i1_2 + ax1)
                                        T.reads(Y_local[v0, v1])
                                        T.writes(Y[v0, v1])
                                        Y[v0, v1] = Y_local[v0, v1]
    

